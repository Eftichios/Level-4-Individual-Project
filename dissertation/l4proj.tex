% REMEMBER: You must not plagiarise anything in your report. Be extremely careful.

\documentclass{l4proj}

    
%
% put any additional packages here
%

\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{vcell}
\usepackage{colortbl}

\begin{document}

%==============================================================================
%% METADATA
\title{A Distributed Game Using Adverts and Trackers In Web Browsers}
\author{Eftychios Karagiorgis}
\date{March 30, 2021}

\maketitle

%==============================================================================
%% ABSTRACT
\begin{abstract}
Targeted advertising systems and tracking in web browsers are highly controversial and cause concerns amongst internet users over privacy of personal data. The controversy in these systems comes from the lack of knowledge that users have of how they work or what data they collect from the users. In this project, we attempt to investigate and improve the knowledge that users have of these systems by creating an interactive online multi-player game that uses tracking and advertising in web browsers as game-play mechanics. 

With the game created, we conducted an experiment that asked participants to play it and found that, within the limitations of our analysis, almost all participants reported that they had an increase in knowledge after playing just a single game.
\end{abstract}

%==============================================================================

% EDUCATION REUSE CONSENT FORM
% If you consent to your project being shown to future students for educational purposes
% then insert your name and the date below to  sign the education use form that appears in the front of the document. 
% You must explicitly give consent if you wish to do so.
% If you sign, your project may be included in the Hall of Fame if it scores particularly highly.
%
% Please note that you are under no obligation to sign 
% this declaration, but doing so would help future students.
%
%\def\consentname {My Name} % your full name
%\def\consentdate {20 March 2018} % the date you agree
%
\educationalconsent


%==============================================================================
\tableofcontents

%==============================================================================
%% Notes on formatting
%==============================================================================
% The first page, abstract and table of contents are numbered using Roman numerals and are not
% included in the page count. 
%
% From now on pages are numbered
% using Arabic numerals. Therefore, immediately after the first call to \chapter we need the call
% \pagenumbering{arabic} and this should be called once only in the document. 
%
% Do not alter the bibliography style.
%
% The first Chapter should then be on page 1. You are allowed 40 pages for a 40 credit project and 30 pages for a 
% 20 credit report. This includes everything numbered in Arabic numerals (excluding front matter) up
% to but excluding the appendices and bibliography.
%
% You must not alter text size (it is currently 10pt) or alter margins or spacing.
%
%
%==================================================================================================================================
%
% IMPORTANT
% The chapter headings here are **suggestions**. You don't have to follow this model if
% it doesn't fit your project. Every project should have an introduction and conclusion,
% however. 
%
%==================================================================================================================================
\chapter{Introduction}

% reset page numbering. Don't remove this!
\pagenumbering{arabic} 

\section{Motivation}
Targeted advertising is the process of serving personalised adverts to users based on an interest profile. To create the interest profile, advertisers use any information that is available about the user, such as information gathered by the user's interaction on social media sites or their demographics. In addition to this information, advertisers also use information gathered by tracking the userâ€™s
browsing activity through various tracking mechanisms. Advertisers then use the interest profile to select what adverts to deliver to the user with the purpose of increasing the number of users interacting with their adverts and maximise their profits. 

Targeted advertising is a big part of the web browsing eco-system and even though it is not essential to the personal browsing experience of the user, it is the main source of income for businesses that provide free services (such as Facebook). With this model, users can in most cases browse the web for free, but this comes at the cost of the user's privacy, and usually without their knowledge or consent. Furthermore, the user usually has no way of knowing what data was used to profile them, as there is a lack of transparency in these systems. Not understanding what these systems do or how they work makes users feel like they have no control over their privacy, which causes concerns over intrusion of their privacy (\cite{intro}). 

In this paper, we attempt to use targeted advertising and tracking in web browsers in a way that is fun and educational with the purpose of directly observing and improving the knowledge that users have of these systems. We also attempt to increase awareness of the various privacy and discrimination issues involved in these systems. It is important for users to have at least some knowledge of how these systems work so they can make more informed decisions when browsing online to preserve their privacy.

\section{Aims}
In order to investigate and improve user knowledge of targeted advertising systems, we created a multi-player online game using adverts and third-party trackers in web browsers as gameplay mechanics. The nature of the game is meant to be educational and experimental; we are not interested in building the most fun game, but rather explore the possibilities of using tracking and advertising in web browsers as game mechanics as an alternative method to expose users to these issues. During the game-play, players can put their knowledge to the test, with the goal of tricking the profiling done by advertisers or getting tracked by a certain amount of third-party trackers, depending on the game mode. The two game modes that were implemented are as follows:

\textbf{Category mode:} Players are given an advert category that belongs to a content category (e.g Arts and Entertainment). Starting with a fresh browser account, they browse the web until they see an advert that belongs to the category given. This will allow the users to explore how the profiling is done by trying out different strategies to be targeted with an advert in that category. The first player to receive an advert in the given category is the winner. 

\textbf{Race mode:} Players browse the web with the goal of getting tracked by a certain number of distinct third-party ad trackers. Third-party trackers can be found in almost all types of websites, but some websites have a lot more trackers than others. The players can devise strategies that maximise the number of trackers identified, which effectively means that they have gained some insight as to what types of websites contain the most trackers. The first player to get tracked by the required number of distinct third-party ad trackers wins.

The game was designed to be multi-player; this allows players to discuss and collaborate with each other, which increases the engagement with the game and makes things more interesting. It also introduces a competitive factor to the game that can act as a motivator for users to improve their strategies. Additionally, after the game, players can see what websites the other players have visited in a summary page, which will be a good starting point for new players to come up with their own strategies.

In addition to the game-play, we include information sections in the game which are meant to re-enforce the concepts seen during the gameplay and help with improving the user's knowledge of tracking, targeted advertising systems and the privacy issues involved in these systems. We also include information sections about different aspects of the game such as how to play the game or information about different aspects of the web app.     

In both game modes, we gather relevant gameplay metrics in order to analyse and evaluate the players' strategies. Additionally, by conducting an experiment that asked participants to play the game while answering survey questions, we evaluate the player's knowledge of targeted advertising systems before and after playing the game as well as the usability of the system in general. In particular, for the users that played the game, the key questions we would like to explore are:
\begin{itemize}
    \item
    What did the user know about targeted advertising systems and tracking, and what did they learn after playing the game (if anything)?
    \item
    Did the user play the game blindly or did they have some sort of strategy in mind? What types of websites were visited by users throughout the gameplay?
    \item
    If the user played multiple games, did their strategy improve over time? Was there a significant difference in the length of the games they played? 
    \item
    Is our system user friendly and enjoyable to use? Did new users have trouble using our system?
\end{itemize}

\section{Content Structure}
We begin in Chapter 2 by providing an overview of related technologies and the state of affairs in online targeted advertising. In Chapter 3, we formalise the requirements and discuss the different aspects of the required solution. Chapter 4 shows the design process and the different aspects of the system on an abstract level. Chapter 5 gives an overview of the software development process that we followed during the development of the product and includes a high level overview of the system architecture. We then discuss the implementation details of the product, where the abstract details given in Chapter 4 are explained in more detail. We separate the independent components of the system and explain their functionality and various challenges encountered throughout the development. In Chapter 6, we describe the experiment we conducted to gather data to help us make conclusions about the players knowledge of targeted advertising systems as well as the system's usability. Additionally, we analyse the gameplay for all the participants in any attempt to explore their behaviour any identify any patterns in their strategy. Finally, in Chapter 7 we summarise the project, discuss the limitations of our product and propose various improvements that could be made to various aspects of the product as well as the evaluation in future work.

%==================================================================================================================================
\chapter{Background}
In this chapter we provide the necessary context information about the entities involved in targeted advertising and how it works, as well as how trackers collect and use the user's data. While we are mostly interested in third-party trackers for the purpose of our game, we also explain how first-party tracking is usually done. Furthermore, we explain briefly the privacy risks and discrimination issues associated with targeted advertising systems. Finally, we conclude with a discussion on related technologies to our game.

\section{Targeted advertising systems}
\label{targeted}
In the early days of the internet, advertising was very limited due to the lack of user data and the lack of resources to display adverts on. This meant that advertisers would commonly place their adverts on any available media that existed, but rather than attracting users, it distracted them and annoyed them (\cite{earlyads}). With the modern advantages in recommender systems and the expansion of the internet with supporting technologies such as cookie matching or real-time bidding, advertisers can now use the context of the user to select what advert to serve to that user.    

\subsection{Entities involved in targeted advertising systems and their roles}
Targeted advertising systems are complex and there are a lot of entities involved that interact with each other in order to serve personalised adverts to users. \cite{Estrada-Jimenez2017} discuss in detail how these entities interact with each other and what implications this might have in terms of privacy issues. We begin by giving a brief and simplified overview of how these systems work. 

Ultimately, the goal of these systems is to deliver the right ads to the right users. The entity responsible for promoting a service or product by serving ads to the users are \textbf{advertisers}, but first they need a 'space' to display their advert  on such that they can maximise their reach of users. Typically, these spaces are provided by \textbf{publishers} and usually in the form of image or video banners in web pages that when clicked, redirect the user to the advertiser's website. Publishers put these spaces on sale and they can either negotiate with advertisers to sell them these spaces or choose to have their ad spaces sold in a real time auction to the advertiser willing to pay the most, in a process called real-time bidding (RTB). It is through publishers that the users are exposed to the adverts. In practise, advertisers do not interact directly with the publishers but rather through ad platforms which provide interfaces that help advertisers and publishers improve their business plan and maximise their profit.

\textbf{Ad platforms} have evolved to make targeted advertising more efficient, transparent and flexible. This lead to more entities becoming involved to handle different parts of the systems. 

\textbf{Ad networks} are responsible for helping advertisers select the most optimal spaces for their adverts (an example of an ad network is GoogleAdSense).

\textbf{Ad exchanges} are responsible for fulfilling a request to display an advert on a publisher's available advert space when a user visits the publisher's website. The ad exchange uses automated auctions to sell these spaces to the advertisers willing to pay the most. They also interact with the advertisers by sharing any data they have on the user that is currently being considered for a targeted advert. This is how the advertiser decides if they want to pay for a particular ad space and what particular advert to serve to the user. These auctions take place when the user visits and is served content on a publisher's website and are usually extremely fast.

\textbf{Demand-side platforms (DSPs)} advise advertisers on what audience they should serve their ads to and on what platform. 

\textbf{Supply-side platforms (SSPs)} advise publishers on how to best use their ad spaces with the purpose of increasing profit and demand. 

\textbf{Data aggregators} or trackers are the entities responsible for collecting information about the users by tracking their online activity, which they share with ad exchanges. Ad exchanges then provide this information to the demand and supply-side platforms.

\subsection{Collecting data}
\textbf{First-party tracking} is done by publishers, usually for the purpose of collecting and analysing the user's information to offer a better experience when using their website. First-party tracking involves tracking the user using first-party cookies, which the user has to give consent before they could be used for advertising purposes. Cookies usually capture implicit data about the user's interactions with the website. Publishers also use data provided by the user, either directly through forms or captured from their network requests, to offer a better experience when using their website.  

\textbf{Third-party tracking} involves tracking the user by embedding content in first party websites (i.e in publisher sites) that allows trackers to monitor the user's browsing activity and capture meaningful data that will later on be used to target the user with personalised content. This content is usually embedded in the website without the user's consent, and in most cases, without the user's knowledge. This content might be third-party cookies or images that are too small to be visible (usually 1x1 pixels) with embedded scripts that monitor the user's interactions in that particular website.

First-party tracking is less of a privacy concern than third-party tracking as it is limited to the users of the publisher's website. Additionally, there is usually more transparency as to what data is gathered and how it is used in first-party tracking. The privacy risks in first-party tracking are directly correlated with the publisher's intentions; publishers can choose to sell private data to ad exchanges or use that data in malicious ways for their own benefit. Third-party tracking on the other hand is a much bigger privacy concern due to the lack of transparency and lack of user involvement. Furthermore, third-party trackers share the user's data with other entities in the targeted advertising eco-system and considering that there is a vast amount of data moving between these entities, any potential data leaks can cause serious privacy issues. 

While different publishers and trackers collect different types of user information, and in some cases, there is no way to know for certain what exact data is gathered from the user, there are types of data that are commonly gathered when tracking the user, which we list below (\cite{addata}):
\begin{itemize}
   \item 
   \textbf{Browsing Behaviour:}
   \begin{itemize}
	\item
           \textbf{Clickstream Data:} A record of web pages that the user has clicked on.
	\item
           \textbf{Search Data:} A record of search terms that the user has queried for.
	\item
           \textbf{Purchase Data:} A record of transactions that the user has either completed or started when using e-commerce sites such as Amazon.
	\item
           \textbf{Other:} Publishers may gather data about interactions of the user that are unique to their site. For example, Netflix gathers implicit data when the user's mouse hovers over an item, to help them make better recommendations for that user (\cite{netflix}).
   \end{itemize}
   \item
   \textbf{Demographics:} Data such as the age, gender or education of the user.
   \item
   \textbf{Social Media Profile Data:} Any data the user has provided for their social media profiles such as their interests or data about the user's interaction on that social media such as the content of the posts they like (\cite{fbook}).
\end{itemize}

\subsection{Process of serving personalised adverts to the user}
From the user's perspective, the ads that they see are part of the website they are visiting. The ads are indeed embedded in the content of the website, but the ads come from third-party advertising domains, and are served when the user's browser sends an HTTP request from the publisher's website to a third party domain that belongs to an ad exchange. Along with the original content that the user would have been served, additional content is served in the form of scripts or ad tags which are executed automatically by the browser. The scripts automatically notify the ad exchange that a space for adverts is available to be filled and the ad exchange then notifies its advertisers. Additionally, using cookie matching, ad exchanges can provide data about the user to the advertisers, and the ad space is then sold to the advertisers willing to pay the most, usually by real-time bidding (\cite{Estrada-Jimenez2017}).

This is a simplified view of how users get targeted with personalised adverts. In reality, many more of the entities mentioned in section \nameref{targeted} are involved in this process, with the ultimate goal of optimising the advertiser's and publisher's profit as well as maximising the perceived interest of the user for the advert to be served.

\subsection{Cookie Matching}
\textbf{Internet Cookies} are commonly used to store information about the user's visit to a website. There are two types of cookies: first-party cookies that are used by the publisher to remember important information about the user that would help improve their experience on that site, and third-party cookies that are used by domains other than the publisher's domain for tracking and advertising purposes (\cite{Estrada-Jimenez2017}). Since cookies contain information such as the user's search logs on a website, advertisers can use cookies to help them build the user's interest profile. 

\textbf{Cookie matching} is the process of identifying multiple cookies that belong to the same user and combining the information that those cookies contain in order to help advertisers select better adverts for that user. To do this, ad exchanges place an identifier cookie on the user's pc when they first deliver adverts to the user. In subsequent visits of the user to websites associated with that particular ad exchange, the ad exchange extracts the identifier cookie and builds a mapping between that cookie and the user. Advertisers can then match their own cookies with the identifier cookie, effectively identifying the user and combining their information to form a more complete picture of the user's browsing activity. (\cite{cm}).

\subsection{Real-time bidding (RTB)}
\textbf{Real-time bidding (RTB)} is an automatic process that happens when a user first visits a website that is associated with an ad exchange. The ad exchange then notifies advertisers that a space is available for advertising and additionally, share any information they have about the user. The advertisers can then use the information shared by the ad exchange along with any information they already have about that user to decide if they want to bid on that ad space. This happens in a real-time auction (usually happens in fractions of a second) where multiple advertisers bid for the ad space and the advertiser who bids the most will have their advert displayed on that space (\cite{RTB}). Figure \ref{fig:rtb} shows the process of RTB and the different entities involved as well as the interaction between them.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/RTB.pdf}    

    \caption{The process of RTB from the moment the user visits a Publisher website. }

    \label{fig:rtb} 
\end{figure}

\subsection{Privacy issues}
We have already discussed how the user's information is gathered in order to build the interest profile. This information can be stored and shared within the actors in the system, often with not enough precaution meaning that potential attacks or data leaks are possible, compromising the privacy of the user. The information can even be sold to third-party organisations for their own purposes, or used to manipulate politics. A good example of political manipulation in advertising is the Cambridge Analytica Data Scandal, where personal user data were gathered through an app and used to assist presidential political campaigns without their consent (\cite{cambridge}).

In a study to explore the sources of personally identifiable information that are used in targeted advertising, \cite{Venkatadri2019} identify a form of first party tracking where Facebook allows advertisers to target their users using personally identifiable information which users have uploaded to Facebook (such as their phone number) without being explicitly told that it can be used for advertising, showing the usual lack of transparency in targeted advertising. This paper also shows the lack of control on the user's site when it comes to selecting what exact data are they willing to share with advertisers. While in some cases, users might have the option to opt out of certain types of advertising, more commonly, the user has no control at all.

Multiple complaints have been filled to regulators across the EU about RTB. One of the complaints, filed by Jim Killock and Michael Veale to the UK's Information Commissioner's Office (ICO) provided evidence that the process of real-time bidding can not comply with the Europeâ€™s General Data Protection Regulation's (\cite{gdpr}) requirement to provide adequate security for the user's data and that RTB was in fact illegal. ICO shut down the complaint without taking any form of action or providing an adequate reason for not taking these complaints seriously (\cite{rtbcomplaint}). In fact, there has been a general lack of action by regulators to address multiple complaints filed about RTB which is very problematic as it shows that the regulators are either not prepared to deal with these complaints or that they deliberately choose not to take any action for reasons that are not known and can only be speculated (\cite{report}).

\subsection{Discrimination Issues}
\cite{Bol2019a} conducted an experiment with the purpose of identifying what advert categories groups of users with different demographics get targeted with. It was found that age, gender and education are all factors in targeted advertising, showing that these systems discriminate user groups in an attempt to maximise their efficiency. An implication of this form of discrimination is that it reinforces the usual age and gender stereotypes (e.g men like cars and women like beauty products). When presented with different discrimination scenarios, users stated that they found 44\% of them moderately or severely concerning and that discrimination based on demographics is more concerning than discrimination based on behaviour (\cite{Plane2017}).

Discrimination in targeted advertising is very problematic as advertisers can take advantage of groups of people that are more suggestible to advertising due to their demographics. For example, constantly showing an older person adverts about skin care can be seen as a marketing strategy that aims to take advantage of the age of that person. While this is a form of personalised advertising, it can also be interpreted as a marketing strategy, where the advertisers exert persistent psychological pressure to force the user to interact with their advert (\cite{fennis2015psychology}).

\section{Related products}
\label{related}
\subsection{Tally Saves The Internet Game}
Tally saves the internet is a browser game released in August 2020 that is implemented as a browser extension in Google Chrome. When users have the extension installed and visit any website, it detects various tracking mechanisms and displays monsters somewhere on the page. The user has the option to fight the monster and defeat it in a turn-based RPG combat, which effectively blocks the trackers identified on the page. It also allows users to earn badges when finding different resources on the web or defeating different types of monsters.

Similar to ad blockers, the purpose of the game is to block tracking, advertising and the collection of the user's data in the browser. The biggest difference is that the game blocks trackers in an interactive manner, requiring the user's attention which ensures that the user is aware of the tracking done on that page (\cite{tally}). 

\subsection{Ad Blockers}
Users receive adverts as HTTP content through HTTP requests. The requests are made when a user accesses a publisher's site, and are out of the users control. This led to the development of browser add-ons that listen to these requests and block them, effectively blocking adverts from being served to the user. 

Ad blockers usually work by monitoring the user's HTTP traffic, and looking at the URL of the domain that each request is made at. This URL is then compared to a list that contains known advertiser domains and is either flagged as an advert or not, depending if the URL is found in the list (an example of such a list is the \cite{easylist}). Alternatively, a domain can be flagged as an advert by identifying key words in the domain URL. If the URL is flagged as an advert, the ad blocker will block that request, which means that the ad content will not be served to the user. Some ad blockers such as the AdblockPlus chrome extension (\cite{adblock}) allow blocking additional traffic, where in addition to blocking requests made to known advert domains, they also block requests made to known tracker domains, which stops trackers from collecting data about the user's browsing activity.

Ad blockers are commonly used to block adverts that disrupt the user's browsing experience or block adverts with irrelevant or offensive messages. For example, when watching videos on YouTube, users are served with potentially non-skippable video adverts of varying length. In a study in the US in 2021 (\cite{stats}), it was found that 27\% of internet users were blocking adverts on their connected devices. 

\subsection{AdReveal}
In an attempt to identify the different targeting mechanisms used in targeted advertising, \cite{Liu2013} performed an experiment to gather data about advert categories throughout various websites. To gather the data, user behaviour was simulated by using search logs gathered by AOL, which is an American online service provider. 
For each user in the search logs, the Bing search engine was used to search for the items in the log and the top 5 websites were visited, and in each website, advert information was collected using the AdReveal tool (a browser extension). The AdReveal tool scans the DOM of the website and gathers the following information: the URL of the page and its semantic categories, the URL of the website the advert redirects to and its semantic categories, and whether a re-marketing script is present on the page. The semantic categories of the pages are extracted by using a web categorisation API. 
This information was collected in two ways: in the first way, search history and cookies were wiped before the entirety of the search. In the second way, search history and cookies were wiped after each individual search. Using these data sets, a machine learning model was built and trained that predicts what kind of targeting mechanism was used for the adverts on the page by calculating a targeting score. An interesting result was that advertisers avoid using behavioural targeting for sensitive ad categories such as health, which shows that advertisers do comply on some degree with the strict guidelines about using sensitive data to build the interest profile.

The three possible targeting mechanisms used in online advertising that the model predicted are as follows:
\begin{itemize}
    \item \textbf{Contextual Targeting}, which uses the content on the page to deliver ads within the same context. For example, if a user visits a sports website, a contextually targeted ad might be an advert about running shoes.
    \item \textbf{Behavioural Targeting} or targeted advertising, which uses the user's interest profile to serve them personalised adverts.
    \item \textbf{Re-marketing}, which delivers adverts to users of products that they have bought, or interacted with in the past.
\end{itemize}


\subsection{Web Categorisation}
Web categorisation is the process of classifying a website into a finite set of predefined categories. This usually works by training a classification model in a supervised manner, which requires massive amounts of data for good performance. The data that the model trains on is usually the HTML content of websites along with their categorisation. The model then learns the relationship between the keywords identified in the HTML content of a site and the different categories. When training is finished, the model can then predict the categories of unseen websites using the knowledge it has gained (\cite{webcat}). It is worth noting that these models are not perfect, because the content of websites can vary a lot and there are websites that are extremely difficult to categorise, due to the ambiguity in their content. 

There are a lot of services that provide web categorisation APIs, which allow you to make HTTP requests to categorise a website using their pre-trained models by including the website's URL in the request. The response will then either be no category, meaning that the model was not able to categorise the given website or a category (or a set of categories) that describes the content of the website.

\subsection{Seamful Games}
Our game falls into the category of seamful games, where the technical limitations inside the game's infrastructure (seams) are not hidden from the user but rather used in a way that allows the user to gain a greater understanding of the concepts that the seams encapsulate (\cite{seams1}). Seams in this case can be seen as the hidden lines between the user and the underlying functionality of the system. In a study by \cite{yoshi}, a mobile game was created called Feeding Yoshi that used different types of WI-FI network securities as well as their coverage to generate different game concepts. This meant that players had the option of selecting a location to play that would maximise the resources inside the game; better locations were considered those that had multiple WI-FI networks with different types of securities. An experiment was then conducted that asked participants to play the game multiple times in different locations, over the period of a week in order to explore how the players will interact with the game in their every day lives. The results of the experiment showed that participants were willing to explore the seams and utilise them in order to optimize their strategy and increase the interaction during the games. This created a fun and engaging experience, showing the potential of seamful designs.

In our game we are not exactly exposing the technical limitations of our game's infrastructure but rather exposing aspects of the targeted advertising systems, which we consider to be seams inside web browsers, as the way they function is hidden from users and they are a big part of the web browser's infrastructure.

\subsection{Blacklight}
\cite{blight} is a real-time website privacy inspector that inspects the different types of surveillance that can be found in websites. It works by visiting the pages in an automated browser and running custom software that identifies: third-party cookies, trackers, key loggers, session recorders, canvas fingerprinting, Facebook trackers, and google analytics re-marketing scripts. Users can interact with Blacklight by inputting a URL of a website in its interface which Blacklight will then visit, run the appropriate software to identify the different surveillance metrics and produce a report which is then displayed to the user. Along with many other metrics, the users can see how many trackers were identified on the page.

\section{Summary}
In this section we have discussed how targeted advertising systems work and the entities and technologies involved in them. We have also discussed the various issues in these systems. These concepts are important for the development of the game, as they are the core of the game mechanics. 

In the related products section, we looked at products that are either similar to ours or use methods that we have adapted and used for the functionality of our system. The closest product to ours is Tally Saves The Internet game, which is also implemented as a Chrome extension and uses trackers as game entities. However, it is still significantly different to what we are trying to do. The product we have built is unique in the sense that it is multi-player and uses both tracking and advertising as game mechanics. 

%==================================================================================================================================
\chapter{Analysis/Requirements}

\section{Initial Proposal and Refinements}
The requirements from the initial proposal involved playing the game using Facebook as the playing ground with fresh Facebook accounts rather than in the browser. Essentially, users would search for pages in Facebook with the purpose of tricking the profiling done by Facebook into categorising them in a way determined by the game itself. However, due to Facebook's guidelines and policies on new accounts and their authenticity, it was not feasible to use Facebook as the playing ground which shifted the focus on using adverts in web browsers instead.

Additionally, the idea of using trackers in the game in addition to adverts came later during the research phase of the project. It was apparent that tracking is a very important concept, and therefore, a new requirement was added to have a game mode involving third-party tracking in browsers.

\section{User Stories}
For this project, we only have one set of user roles; the players. The user stories below reflect the requirements identified during the requirements analysis phase along with any requirements identified later on in the project. We split up the user stories into sections according to what the requirement is. These sections are the different components in the web app that the user would be able to interact with.

\textbf{Authentication/Dashboard}
\begin{itemize}
    \item As a player, I want to be able to register and login, so that I can personalise the experience.
    \item As a player, I want to view game play metrics, so that I can see my progress.
    \item As a player, I want to view my game history, so that I can formulate a strategy based on my best performance.
    \item As a player, I want to be able to view all achievements, including those I have not yet completed, so that I know what achievements to aim for.
    \item As a player, I want to be able to change my password, so that I can ensure the security of my account.
    \item As a player, I want to be able to play the game anonymously, so that I can ensure my privacy.
    \item As a player, I want to be able to change my profile picture, so that I can choose which picture represents my account.
\end{itemize}

\textbf{Leaderboard}
\begin{itemize}
    \item As a player, I want to be able to view the leader board, so that I can see where I rank.
    \item As a player, I want to be able to search the leader board, to see the rank of a specific player.
\end{itemize}

\textbf{Lobby}
\begin{itemize}
    \item As a player, I want to join a lobby before the game, so that I can prepare for the game.
    \item As a player, I want to be able to chat with others before the game, so that I can socialise.
    \item As a player, I want to be able to indicate when I am ready, so that the game does not start without me.
    \item As a player, I want to be able to leave the lobby, in case something comes up.
    \item As a player, I want to be able to vote on the winning condition, so that I can have some control over the gameplay.
    \item As a player, I want to view the winning condition, so that I can formulate a strategy.
    \item As a player, I want to be able to see a helpful status message in the lobby, so that I know when I can start the game.
\end{itemize}

\textbf{Gameplay}
\begin{itemize}
    \item As a player, I want to view the status of the game at all times, so that I can know when the game ends.
    \item As a player, I want to be able to see other player's score, so that I am aware of the state of the game.
    \item As a player, I want to be able to chat with others while playing, so that I can discuss strategies.
    \item As a player, I want to be able to leave the game, in case something comes up.
    \item As a player, I want to be able to play different game modes, so that I can vary my game play.
    \item As a player, I want to be able to earn achievements while playing, so that I am motivated to play.
\end{itemize}

\textbf{Summary}
\begin{itemize}
    \item As a player, I want to be able to view a summary after the game, so that I know who won.
    \item As a player, I want to see the pages I and the other players have visited, so that I can come up with better strategies in future games.
    \item As a player, I want to be able to chat in the summary, so that I can discuss the game with other players.
\end{itemize}

\textbf{Other}
\begin{itemize}
    \item As a player, I want to be able to find information about the game, so that I know how to play.
\end{itemize}

\section{Functional Requirements}
We will now refine the user stories into implementable tasks which we categorise using the MoSCoW prioritisation technique (\cite{moscow}) that labels the tasks into Must Have, Should Have, Could Have and Won't Have according to their relative importance for the functionality of the system. We number the requirements so that we can reference them throughout the paper.

\textbf{Authentication/Dashboard}
\begin{itemize}
    \item[] \textbf{1 - Must Have:} Users must be able to register an account and log in the system.
    \item[] \textbf{2 - Must Have:} Users must be able to view game metrics in the dashboard.
    \item[] \textbf{3 - Should Have:} Users should be able to view their game history.
    \item[] \textbf{4 - Should Have:} Users should be able to view all achievements available for them to complete as well as those they have already completed.
    \item[] \textbf{5 - Must Have:} Users must be able to change their password.
    \item[] \textbf{6 - Should Have:} Users should be able to create an account without providing personally identifiable information.
    \item[] \textbf{7 - Could Have:} Users could be able to update their profile pictures.
\end{itemize}

\textbf{Leaderboard}
\begin{itemize}
    \item[] \textbf{8 - Should Have:} Users should be able to view the leader board.
    \item[] \textbf{9 - Should Have:} Users should be able to search the leader board.
\end{itemize}

\textbf{Lobby}
\begin{itemize}
    \item[] \textbf{10 - Must Have:} Users must be able to join a lobby before the game.
    \item[] \textbf{11 - Must Have:} Users must be able to chat with other players during the lobby.
    \item[] \textbf{12 - Should Have:} Users should be able to indicate that they are ready before the game can start.
    \item[] \textbf{13 - Must Have:} Users must be able to leave the lobby.
    \item[] \textbf{14 - Could Have:} Users could be able to vote on the winning condition in the lobby.
    \item[] \textbf{15 - Must Have:} Users must be able to see the winning condition in the lobby.
    \item[] \textbf{16 - Must Have:} As a player, I want to be able to see a helpful status message in the lobby, so that I know when I can start the game.
\end{itemize}

\textbf{Gameplay}
\begin{itemize}
    \item[] \textbf{17 - Must Have:} Users must be able to see the status of the game while playing.
    \item[] \textbf{18 - Must Have:} Users must be able to see the score of other players while playing.
    \item[] \textbf{19 - Must Have:} Users must be able to chat while playing.
    \item[] \textbf{20 - Must Have:} Users must be able to leave the game.
    \item[] \textbf{21 - Should Have:} Users should be able to play multiple game modes.
    \item[] \textbf{22 - Should Have:} Users should be able to complete achievements.
\end{itemize}

\textbf{Summary}
\begin{itemize}
    \item[] \textbf{23 - Must Have:}  Users must be able to view a summary of the game when the game ends.
    \item[] \textbf{24 - Should Have:} Users should be able to see the pages they and the other players have visited.
    \item[] \textbf{25 - Must Have:}  Users must be able to chat with other players in the summary page.
\end{itemize}

\textbf{Other}
\begin{itemize}
    \item[] \textbf{26 - Must Have:} Users must have the ability to read information about the game before playing.
\end{itemize}

\section{Non-Functional Requirements}
In addition to the implementable tasks identified, we also identify tasks that are related to the behaviour of our system rather than what the user should be able to do. These requirements are few, but are very important for the functionality of the system.  

\begin{itemize}
    \item[] \textbf{1 - Must Have:}  The system must be able to handle updates to the game state in real time.
    \item[] \textbf{2 - Should Have:} The system should be easy to use for new users, without requiring a lot of background information.
    \item[] \textbf{3 - Must Have:} The system must be able to handle multiple games at the same time.
    \item[] \textbf{4 - Must Have:} The system must only store information that is not sensitive and only relevant to the gameplay.
\end{itemize}

\section{User Journey}
To give a more practical overview of the requirements, we provide a brief overview of the user's journey from account creation to playing the game. We include the requirements that have to be implemented under each step:
\begin{enumerate}
    \item The user registers for an account and logs in.
    \begin{itemize}
 	\item \textbf{Requirements: } [\#1, \#5, \#6 ]
    \end{itemize}
    \item The user reaches the dashboard.
    \begin{itemize}
 	\item The dashboard shows the user's achievements, their game history and game-play metrics (such as games played, total number of trackers found, etc...).
           \item The leaderboard is also accessible from the dashboard.
	\item It also has relevant information on how to play the game and a 'Find Game' button .
           \item Users can change their profile picture from the dashboard.
 	\item \textbf{Requirements: } [\#2, \#3, \#4, \#7, \#8, \#9 ]
    \end{itemize}
    \item The user reads how to play and searches for a game.
    \begin{itemize}
 	\item \textbf{Requirements: } [\#26 ]
    \end{itemize}
    \item When a game is found, the user is put inside a lobby.
    \begin{itemize}
 	\item The lobby allows users to chat with each other before the game starts.
           \item The lobby shows the winning condition  (i.e number of unique trackers to get tracked by or advert category depending on game mode) and a status message.
           \item Users must indicate that they are ready before the game can start.
 	\item \textbf{Requirements: } [\#10-16 ]
    \end{itemize}
    \item When all users are ready, they can start the game.
    \begin{itemize}
 	\item During the game, the users visit websites and can see the current state of the game.
           \item The users can also chat during the game through the lobby.
 	\item \textbf{Requirements: } [\#17-22 ]
    \end{itemize}
    \item A winner is found and the users get redirected to a summary page.
    \begin{itemize}
 	\item The summary page uses the final game state to build relevant gameplay metrics that the users can see.  
           \item User achievements, metrics and game history are updated.
           \item Users have the option to leave the summary or play again.
 	\item \textbf{Requirements: } [\#23-25 ]
    \end{itemize}
    \item Users leave the summary and are redirected to the dashboard.
    \begin{itemize}
        \item In the dashboard, they can view their updated achievements, metrics and game history.
    \end{itemize}

\end{enumerate}


%==================================================================================================================================
\chapter{Design}
In this chapter we provide an overview of the system and how the various components of the system interact with each other. Then, for each of these components we discuss the design details for the most notable parts.

\section{Overview}

\subsection{System Components}
When designing the infrastructure of the system, the requirements that limited the scope of technologies to use were the fact that the game must be multi-player and played in web browsers. The only way to fulfil these requirements is to implement the game as a web application. There was an apparent issue however; to build the gameplay logic, we need a way to monitor the user's browsing activity in sites outside of our domain which can not be done with front-end or back-end technologies. This led to the addition of another component into the infrastructure of the system; the browser extension, which gives us access to the user's network requests that we use to identify third-party trackers, and to the HTML content of each site the user visits during the game that we use to identify adverts.

The system can then be logically split into three high level components; the server, the client and the browser extension. These components work together to form the complete system.
\begin{itemize}
    \item
    \textbf{Client:} This will be the front-end that will allow users to interact with the system.
    \item
    \textbf{Server:} The server will handle all network requests, along with any database operations. Additionally, the server will handle the communication between the clients and the extensions to handle updates to the game states for each player.
    \item
    \textbf{Browser Extension:} The extension will handle all gameplay logic and provide feedback to the players of the current game state during an active game.
\end{itemize}

\subsection{System Architecture}
Figure \ref{fig:sysarch} shows the system architecture diagram with the three components and the interactions between them. The three components of the system interact in two different ways:
\begin{itemize}
   \item
   \textbf{HTTP requests:} Both the client and the extension interact with the server through HTTP requests. The client interacts with the server to authenticate users, retrieve database data and handle any functionality of the web application outside the game. The extension interacts with the server to retrieve the user's information as well as to categorise adverts identified during the gameplay.
   \item
   \textbf{Web sockets:} To handle three-way, real-time communication between the components of the system, we use web sockets. Web sockets allow us to set up TCP communication lines between the clients and the server and communication lines between the extensions and the server. Note that there is no direct communication line between the extensions and the clients; the server acts as an intermediary when these component want to communicate. 

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/sys_arch.pdf}    

    \caption{System Architecture diagram with the three main components of the system and the interaction between them.}

    \label{fig:sysarch} 
\end{figure}


To communicate, web sockets emit events and there are corresponding event listeners that listen to those events and handle any logic necessary. We can also pass additional data when emitting events. For the purpose of our game, we set up events and event listeners to web sockets to handle updates to the game state for all players in real-time as well as to implement the chat functionality. Web sockets also allow us to put users into different socket rooms, which we use to support multiple games being played at the same time.
\end{itemize}

\section{Game Mode Design and Evaluation:}
The project specification required the implementation of just one game mode. However, during the design phase of the project, we have decided to implement more game modes to showcase more concepts in targeted advertising systems. But first, we needed to evaluate these game modes to determine if it is worth implementing them and identify any potential problems or improvements.

Three game mode design prototypes were created in total which were presented in a survey, along with questions aimed at evaluating the perceived engagement that these participants would have with the game. The three game mode designs are as follows:

\begin{itemize}
   \item
   \textbf{Race Mode:} This game mode will be utilising third-party trackers as the main gameplay mechanic. It will be a very simple racing game, where the winner is the player that gets tracked by a certain amount of third-party trackers first.

   \item
   \textbf{Category Mode:} This game mode will be utilising adverts on pages as the main gameplay mechanic. Players will be given an advert category and the purpose of this game mode is to browse the web until a player is served an advert that belongs to the category given. The first player to be targeted with an advert in that category wins the game.

   \item
   \textbf{Hunting Mode:} This game mode is different than the other two in the sense that it does not involve active gameplay. Players can choose to have the extension activated in hunting mode while they are casually browsing the web. The extension will then identify any trackers and try to pull additional information about that tracker such as their location and their organisation name. Players will then have a collection of found organisations that correspond to trackers.
\end{itemize}

In total there were six responses to the survey, the survey along with the results can be found in the appendix. All participants stated that they would play all three games modes, with the exception of one participant stating that they would not play the Hunting game mode. However, participants stated that the game modes would get boring after playing a few games. Additionally, some aspects of the game modes such as the purpose of the hunting mode seemed confusing to participants and so improvements and changes had to be made in order to make the gameplay more interesting and engaging.

Therefore, following the evaluation results, we have decided to completely drop the Hunting game mode and add aspects of the hunting mode, such as the organisation collection to the Race mode. We are therefore left with two game mode design prototypes: the Race mode and the Category mode.

\section{The Server}
The server implements a REST API that both the client and the extension use. It handles most of the functionality of the web app and the gameplay. The server connects to the database to handle any database operations. 

\subsection{ER Diagram}
We chose a relational database as it is the most appropriate for our project. With the relational database we can model the interactions between users and their gameplay metrics or achievements, such that it is easy to query the database for the user's information. Figure \ref{fig:ER} shows the ER diagram for the relational database. The tables with an asterisk at the start of their name have no relationship with other tables and were created to store useful information about the gameplay and the interactions between users and our system. The Logs table contains entries for actions that users perform in our system, and have additional information that will help us evaluate the system and identify any errors. The Ad\_Category table is used to store the advert images along with their categorisation during the gameplay. If a user finds an advert during the game that was previously classified in the same or another game, we query the database to retrieve the categories instead of categorising the advert again.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/ER_diagram.pdf}    

    \caption{The ER diagram, showing the database tables and their attributes as well as the relationships between them. Database tables with an asterisk in their name have no relationship with other tables. }

    \label{fig:ER} 
\end{figure}

\subsection{REST API}
The server uses a controller that sets up all REST API routes, which makes it easier to handle any server-side errors. The routes correspond to the database tables and for each table we have routes to retrieve, insert, update or delete entries from the table. This allows us to handle user registration and authentication, game metrics and achievement updates, game history updates and any retrieval requests such as retrieving the user's achievements or gameplay metrics. There are also additional routes that are not related to database operations, these routes handle requests to find or start a game and the logging of various events in the system.

\section{The Extension}
The main role of the extension is to handle the gameplay logic but an equally important aspect of the extension is its interface. Players must be able to view the state of the game while playing; this includes being able to view their own score along with the score of the other players. In addition to that, it should display the status of the game so that the players know when the status of the game changes.

We will now discuss briefly the design aspect of the gameplay mechanics and what data we are interested in storing from the gameplay.

\subsection{Tracker identification}
For the Race game mode, the extension needs to be able to identify third-party trackers during the game for each player and count them. This means that the browser extension needs to be able to know when a game starts and execute its logic only when the game is active. In each page that the user visits during the gameplay of the Race mode we are interested in two different pieces of information: the URL of the site, and the number of unique third-party trackers identified on that site. Unique third-party trackers means third-party trackers that have not yet tracked the player during the current active game.

\subsection{Advert identification and categorisation}
Similar to identifying trackers, the extension must only execute its logic while a game of the Category mode is active. For this game mode we are again interested in the URLs of the pages that the user visits during the game, as well as the redirection URLs of any adverts found during the game along with their categories and their image. 

\section{The Client}
The client (front-end) will act as the platform where users can search for and play games. It needs to be able to handle all user interaction with the various components of the web app, but also be simple and easy to use.

\subsection{Wireframe Prototypes}
When designing our web app's interface, we wanted to keep things simple and as minimal as possible while still creating an intuitive and easy to use interface. During the prototyping phase of the project, we have created two different sets of wireframe designs for the user interface of the web app using Figma (\cite{figma}). Figma allows the creation of interactive prototypes that can simulate the functionality of each page. We then created a survey and asked participants to answer which of the two different designs they preferred. The survey along with the responses can be found in the Appendix. Figure \ref{fig:wireframe} shows an example of the two different designs for the dashboard page; the idea for the first design was to include all page components in cards, and use tabs to navigate between a play screen and the dashboard. The idea for the second design was to include everything in one screen and make it span the whole page. We also use different colour schemes for the two designs and ask participants to state which colour scheme they preferred.

In total, seven participants took part in the survey and the results were that the majority of participants (4 out of 7) preferred the colour scheme of design 1, which was blue for primary actions on the page and orange for secondary actions compared to purple and cyan for the design 2. In terms of the UI, all participants stated that they preferred design 2 over design 1 for all screens. Therefore we have chosen to combine the colours of design 1 with the UI of design 2 to get our final design. Figure \ref{fig:finaldesign} shows a prototype wireframe of the dashboard screen after the evaluation of the survey.
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/Dashboard.png}    

    \caption{Two candidate designs for the dashboard page of the web app as they were presented to participants of the survey. Participants stated whether they preferred the left (Design 1) or right design (Design 2). }

    \label{fig:wireframe} 
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/DashboardFinal.png}    

    \caption{The prototype wireframe for the Dashboard after evaluation of the survey responses. }

    \label{fig:finaldesign} 
\end{figure}

\subsection{Web App Components}
The interface of the web app can be split into different components. We briefly mention these components along with any functionality they provide to the user.

\textbf{Authentication:} These are the register and login pages which will be the first thing new users will see when they visit the web app. New users can create accounts and existing users can use their credentials to log in, in which case, users are redirected to the dashboard.

\textbf{Dashboard:} The dashboard will be the main screen of the web app where most user interaction happens. In the dashboard, the user can search for games, view the leaderboard, game metrics, achievements and game history, change their profile picture or their password and find information on how to play.

\textbf{About:} The about page is the only page the user can navigate to other than the dashboard. It contains information about the concepts used in the game, as well as information about the game. The about page is meant to assist in improving the user's understanding of targeted advertising systems and the various issues involved with it. 

\textbf{Lobby:} When a user searches for and finds a game, they are redirected to the lobby. The lobby allows players to chat with each other before the game or during the game. Additionally, players can see what the required winning condition is and indicate that they are ready for the game to start. When all players are ready, any one of them can start the game. During the game, players remain in the lobby, where they can continue chatting or choose to leave.

\textbf{Summary:} When a winner is found, players automatically get redirected to a summary page where they can see who won, and their own or other players gameplay metrics. For example, in the case of the Race mode, users can see the pages other players have visited along with the number of unique trackers found in each page and their domains. Players can continue chatting in the summary until they either choose to leave the summary page or play again. 

\section{Technologies used}
There were many technologies that we could have used for the development of the various components of the system. There were no limitations from the project specification, but since we are interested in tracking and 
advertising in web browsers, it was clear that we needed a JavaScript framework for the web application. Furthermore, to keep the language unified and consistent across our system components, we will also use a JavaScript framework for our
back-end, which will make it trivial to share resources between the server, client and extension using JSON data. 

\subsection{The Server}
The server needs to be able to handle authentication of users, communication between users and handle HTTP requests along with any database operations. Furthermore, since the game supports multiple players, we need
our server to be able to handle requests asynchronously so that it is non-blocking. The best choice for these requirements is implementing the server in Node.js along with Express since it provides most of the functionality we need out of the box, reducing the overhead
on additional libraries.  

\subsection{The Client}
The client needs to be able to handle all user interactions and display of information in the browser. There are a few different options we could have chosen for the client. The first option is vanilla JavaScript which is the most lightweight
with no overhead of additional libraries. However, with vanilla JavaScript it can be hard to implement more complex functionality. The second option is React, which is a component based web framework using a virtual DOM to render HTML 
content quicker. The third and final option is Angular, which supports two-way data binding, meaning that changes in the DOM will be reflected in the application code. However, Angular requires many libraries for efficient use, resulting in a lot
of overhead.

Hence, we have chosen to implement the client in React, as it is faster than Angular for smaller scale apps and supports real-time updates to the DOM using component lifecycles. Furthermore, using components will make development easier, as they
can be reused in different parts of the app.

\subsection{The Extension}
The extension needs to be able to handle all gameplay logic as well as displaying feedback to the users when they are in an active game. This means that it should be able to make updates to its interface that correspond to updates in the game state.
Therefore, we need our extension to have scripts running in the background that can handle the gameplay logic as well as scripts than can handle the updates to the interface. We have chosen to implement the extension in Google Chrome, as it is the
most widely used browser and the Google Chrome developer API provides many useful event driven methods that can help us detect trackers or identify adverts.

Google Chrome extensions are similar to web applications, in the sense that we can use web frameworks to implement them. However, for our extension we have chosen to go with vanilla JavaScript instead of using frameworks such as React or Angular.
This is because we are mostly interested in the scripts rather than the interface, and the Google Chrome developer API is powerful enough to help us implement the complex functionality required.

\subsection{Database}
For the relational database, we could have chosen any of the SQL databases as they all have the capabilities to handle any operation we might need for this project. However, for the selection of the database, we have decided to look ahead to the deployment of the 
app to avoid any potential incompatibilities between the service we will use to deploy the app and the database. 

A good service to deploy web apps that is free and supports automatic deployment is Heroku (\cite{heroku}). Heroku has add-ons that can be added to the deployed app which provide cloud databases that
our app can connect to. One of the most supported and commonly used add-ons is the Heroku PostgreSQL which is what we will be using. Using PostgreSQL also makes it easy to store and query JSON data, which will be convenient when we want to store or retrieve entries for database tables that contain dynamic data, such as the game history.

%==================================================================================================================================
\chapter{Implementation}
\label{implementation}

In this chapter we discuss the implementation details for the most important aspects of the different components of the system. This is by no means a comprehensive and exhaustive discussion, as we avoid delving into much detail and exclude parts of the system that we assume are trivial to implement and require no further explanation. 

We start by briefly explaining our software development process which was put in place to ensure that the project was organised and that most good software practises were followed. We then start by describing how we handled the communication between the different components of the system and continue by discussing the implementation details for the three components of the system as well as the database.

\section{Software Development Process}

\subsection{Version Control and Agile Development}
For our version control we used GitHub (\cite{github}) as our remote repository. Most of the development and implementation of new features was done on the master branch. While we could have used a branching strategy to implement and test new features before merging them in the master branch, we did not feel like this was needed.

During the development of the product, we followed the Agile Scrum methodology (without the team roles) so that we could be flexible with the requirements as well as be organised with the tasks that we had to complete. Development happened in two-week sprints, where in each sprint we implemented one or more major features corresponding to the issues that were selected for that sprint. Issues were created to reflect the user stories during the requirement elicitation phase and further issues were created during development as necessary. 

GitHub provides a Kanban board which we used to organise issues into the backlog and the active sprint. For each sprint, issues were organised into four columns: To Do, In Progress, Done or Discarded. Each issue had additional labels denoting its priority, what the issue was about and what part of the system it affected. Since GitHub issues have no metadata for time tracking, we used a chrome browser extension called Clockify (\cite{clock}) to keep track of the time each issue took to complete. This allowed us to reflect on each sprint and ensure that time was spent on the more important issues. We also used Github's wiki to document any necessary aspect of the system as well as document our progress.

\subsection{Continuous Integration and Development}
An important aspect of Agile Development is CI/CD, which ensures that the implementation of new features does not break the existing functionality of the system. To deploy the app on Heroku, our repository had to have a specific structure, and therefore we created a deployment branch that has the appropriate code structure for deploying the app. GitHub actions allow us to define pipelines that execute a sequence of commands every time we push to the repository. We set up two different pipelines, one that runs automated tests whenever we push to the master branch, and another pipeline that deploys the app on Heroku when we push to the deployment branch. This way, when the first pipeline fails, we know that something has broken and needs to be fixed before  pushing to the deployment branch.

\section{Web sockets with Socket.io}
Before we begin explaining the implementation details for each component in the system, let us first discuss how we have implemented the web sockets to handle the three-way communication between these components. We implemented the web sockets using Socket.io, which is a JavaScript library that provides an API to set up socket event emitters and event listeners. There are two different types of sockets, server-side sockets which will sit on the Node.js back-end and client sockets which will sit on the React front-end and the Chrome Extension for each of the users. 

Both types of sockets can emit events that the other type of socket can listen to, but client sockets can not listen to events from other client sockets. This means that for the client and the extension to communicate, they need to go through the server. This can be done by having event listeners on the server that listen to individual client socket requests and then emit an appropriate event to either a subset of the other clients or all of them, effectively allowing the client sockets to communicate indirectly.

From the user's perspective, they each have two sockets set up in their browser, one for the web app and one for the extension. The socket in the web app is mostly responsible for the chat, as well as reflecting updates to the game state in the web app. For example, when a winner is found, the extension socket notifies the server, which in turns notifies all connected clients and they are then redirected to the summary page. The socket in the extension is mostly responsible for sending game state updates to the server, which the server in turns sends to all connected extension sockets. It also has event listeners to identify when the game starts or when a user leaves the lobby so it can update its interface accordingly.

The server-side sockets are responsible for setting up the appropriate event listeners to handle the indirect communication between all client sockets. More details into what specific events are set up are given in the appropriate sections for each component.

\section{The Server}
The server uses Express along with Node.js to implement an HTTP server and expose routes that the clients can consume through HTTP requests. To handle the requests, the server communicates with the database to retrieve any necessary information. Additionally, the server has utility classes to handle more complex functionality such as updating the user's achievements or dealing with the creation of lobbies. 

\subsection{Logging}
For each request made to our server, we keep a log that contains the request data as well as our server's response data. This makes it easy for us to identify and fix an potential errors in our server's controller logic. To do this, we define a middleware for each route that listens to an event indicating the completion of the request, and uses the data of the request and response to store entries in the database in the appropriate format.

Since we are interested in evaluating the system, we also store a log entry in our database for user interactions during gameplay. For example, when a user finds a unique tracker during gameplay, we store an entry to note the time and the website the tracker was found as well as the tracker's information. Since these interactions happen outside of the server and we need to store them in the database, we define a route that the react app can consume and send a request to the server to log a particular entry.

\subsection{The Lobby System}
To support multiple games being played at the same time, we had to implement a lobby system. The lobby system essentially puts users into different lobbies depending on the selected game mode. When a user searches for a game, a lobby handler class either creates a new lobby if no available lobbies exists, or puts the user in an already existing lobby. Available lobbies are lobbies that are not yet full and are of the same game mode that the user is searching for. This process is shown in Figure \ref{fig:lobby}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/lobby.pdf}    

    \caption{The process of putting a user into a lobby when they search for a game and the different parts of the systems that are involved in this process. Steps are numbered to show the order of interaction between these components.}

    \label{fig:lobby} 
\end{figure}

A lobby is its own class, and it is initialised by the lobby handler by passing in the game mode and an index which is used to differentiate between lobbies. The lobby also has attributes to store the users currently in the lobby, set the maximum number of players allowed in the lobby, and other useful game related attributes such as the winning condition for that lobby. The winning condition is selected randomly out of a subset of winning conditions when the lobby is first created. Appropriate methods are also defined to add or remove players from the lobby, and handle any other lobby functionality such as checking if the lobby is full or checking if all the players in the lobby are ready.

When the user is put in the lobby, their corresponding sockets are put into rooms. The browser socket is put into one room and it has event listeners and emitters to handle the chat functionality in the lobby, detect when a user leaves the lobby, detect when the game is finished and detect when all users are ready so it can enable the start game button which is disabled until all users are ready. The extension socket is put in a different room and has socket events to handle all the gameplay logic, update the game state for all players and detect when a game starts or finishes. The sockets stay in the rooms for the duration of the game as well as when the users are redirected to the summary page, since users can chat in the summary as well. When the users either leave the summary or leave the lobby during an active game, we remove their sockets from the rooms and remove the user from the lobby. When all users leave the lobby, the lobby handler destroys that lobby since it is no longer needed.

\subsection{Chat System}
Users that are inside a lobby have their browser socket inside the same room. When a user sends a message to the chat, their socket emits an event to the server with the information of the message. The server-side socket listens to this event, and then emits an event to all the remaining browser sockets in the room with the information of the message. The remaining browser sockets in the room listen to this event and append the new chat message to the chat container. Message information includes the user's username, the message that they typed and the date-time the message was sent. This allows the front-end to display the username of the user that send the message, what the message is and at what time was the message sent.

The server can also chat with the players through its socket, and we do this to inform players that other players have joined or left the lobby.

\subsection{Updates to the state of the game}
When a game starts, an initial game state is created by the server that contains information about the players in that game, including their gameplay metrics such as the unique tracker count in the case of the Race mode or their page history. When the game starts, the server emits an event to all extension sockets to inform them that a game has started but also to send them the initial game state. During the game, when a player finds a new tracker, the extension increments their score in the game state by one and then emits an event to the server informing it that the game state of that player has changed. The server then emits an event to the remaining extension sockets with this new game state. The extension sockets then compare the new game state with their current game state and make the appropriate changes.

When a player wins the game, their extension socket notifies the server that a winner is found. The server then notifies all other players that the game is over and a winner was found and waits until all players have reported back their game state. When all players emit their game state to the server, the server puts everything together to create the final game state, which is used to create the summary page as well as the game history.

\subsection{Achievement System}
To handle updates to the player's achievements, we created an achievement handler which is a class that has methods to handle any achievement updates. The achievement handler executes its logic one step before players are put in the summary page. 

Each achievement has a condition which is an integer number that reflects the requirements of the achievement. An example achievement is "Play 5 games of the Race mode" and the corresponding condition would be 5. Furthermore, achievements have labels such as "race" to identify which metric to check against their condition, which allows us to dynamically check all achievements. The achievement handler takes in the final state of the game and for each player it retrieves their previous gameplay metrics and uses the gameplay metrics from the final game state to check if the player has passed the condition to complete an achievement. If a player had previously played 4 games of Race mode and has just finished another game of Race mode, for all achievement that have the "race" label, it would compare this new sum with the condition of that achievement and either mark the achievement as completed if the sum is more than or equal to the condition or mark it as In Progress if it is less. If no progress is made in a specific achievement then that achievement is marked as Not Started. This allows us to only check for achievements that have not yet been completed.

\subsection{User Gameplay Metrics}
Similar to the achievement handler, the user's gameplay metrics are updated one step before players are put in the summary page and it is a very simple process. A metrics handler class takes the final game state and for each user, it retrieves their previous gameplay metrics, adds to those metrics the metrics extracted from the final game state and updates the entries in the database. The metrics handler has appropriate methods to handle updates to the user's gameplay metrics for both game modes.

\subsection{User Authorisation/Authentication}
To authorise users within our app we use JSON Web Tokens (\cite{jwt}) to create an encrypted token using the user's data and a secret key which we define. When a user registers for an account or logs in to the web app, a jwt token is created and stored in the user's local storage for the remainder of their browsing session or until their token expires. For HTTP resources that require user authentication, we define a middleware that checks whether the HTTP request has a valid jwt token in its headers. We can check whether a token is valid by using the secret key to verify it. If the token is invalid or not provided inside the request's headers, we return an error with status 403, indicating that the user is not authorised. The user is then redirected to the login page, which stops them from using functionality inside the web app that requires user authentication.

\subsection{Database and ORM}
To implement our database models and handle database operations we use \cite{sequelize} which is on Object Relational Mapper (ORM) that functions as an interface between the server and the PostgreSQL database. Using an ORM instead of executing SQL statements directly to our database eliminates the risk of SQL injections, but also makes it easier for us to define models by using the interface that Sequelize provides. We define a model for each database table with the appropriate fields as identified from the ER diagram we have created in the Design chapter. We further define the relationships between these models such that we can associate primary keys to foreign keys.

During development, we created a population script for our database that initialises the database tables also populates them with dummy data, or real data in the case of the achievement table. 

\subsection{REST API}

\subsubsection{Common Routes}
For the REST API, we define routes to retrieve, update and store information to the database tables. The routes are defined in separate controllers, one for each database table. Each controller has methods that correspond to each route and return an HTTP response object that contains the status of the request and the data that the client requested. Figure \ref{fig:restapi} shows an example of a user making a request to a particular REST API controller to retrieve data from the database.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/restapi.pdf}    

    \caption{A user's client making an HTTP request to on of the server's REST API controllers. The controller interfaces with Sequelize to retrieve data from the database which are then returned to the user as an HTTP response object.}

    \label{fig:restapi} 
\end{figure}


\subsubsection{Gameplay Routes}
We also define routes that are not related to database tables, to handle complex game related functionality. When a user searches for a game, a request is made to the server with the user's information. The user then handles putting the player into the lobby and putting the player's sockets into rooms with the appropriate event listeners and event handlers. When all users are ready inside the lobby and start the game, a request is made to the server. The server then builds an initial game state with the appropriate data structures to store game related data and shares the initial game state with all players through their extension socket. For the remainder of the game, the server handles game state updates through the sockets until a winner is found. In the case of the Category game mode, the server has an additional route that handles the categorisation of adverts. These requests are made from the extension when an advert is identified during the game. The request contains the URL of the advert's landing page. The server then queries the database to see if it had previously categorised that URL, in which case, it retrieves its categories. If the URL was not found in the database, the server makes a request to a web categorisation API that categorises the URL and returns its categories or no category if it was unable to categorise that particular URL. The server then stores a new entry for this URL in the database and returns the categories.

When the game is over and a winner is found, the server then uses the final game state to build the game history and calls the appropriate methods to handle updates to the achievements and metrics of each player. Finally, the server emits an event to the browser sockets with the final game state and they are redirected to the summary page. The web app uses the final game state to display the appropriate information to the users.    

\section{The Client}

\subsection{React Component Diagram}
In Figure \ref{fig:react}, we can see the React component diagram, showing the different components in the web app and the interaction between them.
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/react_comp_diagram.png}    

    \caption{React Component Diagram showing the hierarchy of the components in the web app, as well as the interactions between them. Arrows with a full black head means that the parent component navigates to the child component. Arrows with an open head means that the parent component is made up of the child components.}

    \label{fig:react} 
\end{figure}

\subsection{Components}
React components have little knowledge of other components in the system and communicate through props, where one component can pass props to another component which correspond to data we want to share between the components. Each component is implemented as a JavaScript class and uses these props, along with additional states and methods to build that component's logic. Additionally, each component has a render method that returns the HTML content to be displayed on the page. We will not go into detail for the implementation of each specific component, but instead explain our general approach for implementing each component's logic.

\subsubsection{Component logic}

Each component has a constructor, that takes in the props given to it by its parent component. We initialise the props as well as an initial state to handle the functionality of that component. React has lifecycle methods, that execute when specific events occur on the page. One of those methods, is the \textit{ComponentDidMount} method, which executes once after the component gets mounted on the DOM. We use this method to execute any necessary HTTP requests to retrieve data from the database to display on the page. We use the HTTP response to create HTML elements that contain the information from the database we are interested in displaying and store the HTML elements in state values. We then use those state values in the component's render method to display the  HTML elements. Using states for rendering the HTML allows us to reflect any changes in the state values to the rendered HTML, as React detects when changes are made to state values and re-renders the component.

Each component has additional methods that are specific to that component's functionality. These methods might correspond to user actions or form submissions.

\subsubsection{Rendering The HTML}
The render method of the component allows us to write HTML directly in the JavaScript class and use any of the classes attributes or methods to deal with rendering dynamic content. We use Bootstrap classes and Cascading Style Sheets (css) to deal with the positioning of the different elements on the page as well as their styling. Figure \ref{fig:dash_deploy} shows the dashboard of the final version of our app. 

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/dash_deploy.png}    

    \caption{The Dashboard component of the deployed app.}

    \label{fig:dash_deploy} 
\end{figure}

\section{The Chrome Extension}
The Chrome Extension consists of two parts: the interface, which can be toggled by clicking on the extension's icon in the browser and the scripts that handle the functionality of the extension.

\subsection{Extension storage}
To handle the game-play logic we have defined different types of scripts that need access to the same variables or data structures to handle the logic. Therefore, to allow different scripts to access the same variables, we use the extension's local storage API, this way we can access the local storage directly from each script instead of having to set up communication between scripts. Furthermore, the API provides events listeners that listen to any storage changes and execute a callback function. We use the API along with variables used as flags to detect different state changes in the game.

\subsection{Interface}
The interface of the extension is fairly simple and it displays information about the game only when users are in an active game. This provides feedback to the user of the state of the game and the scores of other players. To handle real time updates to the extension's interface, we embed a script in the html content of the interface that listens to any changes to the storage of the extension. When something changes in the storage, we check to see if it was the game state, in which case, we use the new game state to modify the values of our HTML elements dynamically. Figure \ref{fig:ext} shows the final interface of the extension for both game modes while the player is in an active game with 2 other players. The player can see the winning condition, their own number of unique trackers in the case of the Race mode or the latest category found along with its image in the case of the Category mode. The player can also see the unique tracker score of other players in the case of the Race mode and the latest category the other players have found in the case of the Category mode.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/ext.png}    

    \caption{The extension's interface when a user is in an active game. The left screenshot shows the interface in an active game of Race mode, while the middle and right screenshots shows the interface in an active game of Category mode.}

    \label{fig:ext} 
\end{figure}

\subsection{Tracker identification}
Chrome extensions allows us to define scripts that run in the background, meaning that these scripts are active on all pages. To identify trackers we use a background script with two main functionalities, implemented by utilising the Google Chrome developer API. The first functionality is to ensure that the script only executes its logic when the player is in an active game. This means that the script should be aware when a game is active or not. To implement this we set up an event listener to listen for changes in the extension's local storage. We then check if there is any value changes to particular flags used to indicate that a game is active or not. Using these flags we can then decide when to execute the scripts logic. The second and most important functionality of this script is identifying and counting trackers while also emitting events to the server to update the game state for all other players. An event is also emitted to the server when the player wins. 

To identify trackers, we use a similar technique as that used by ad blockers but instead of blocking the request, we simply count it. In particular, we set up an event listener that listens to the user's outgoing HTTP requests. For each of those request we extract the domain of the URL the request is made at and compare it with a list that contains domains of known third-party trackers. If the domain we extracted is in that list, then that particular request was made to a third-party tracker's domain which effectively means they are tracking the user and therefore, we can add one to that player's tracker count. To make the gameplay more interesting and stop users from visiting the same pages, we only count unique third-party trackers, which are trackers that the user has not yet been tracked by during that particular game.

\subsubsection{Page specific tracking}
When we extract the domain of the URL the request is made at, we also extract the domain of the URL the request is made from (the publisher's domain). We can then identify on what page a particular tracker was found which we use to build the summary as well as the player's game history. This is perhaps the most useful piece of information for the purpose of analysing the tracking done in different types of websites, as well as providing more transparency into the massive scale of tracking done to the players through the extension's interface.

\subsubsection{Optimizing the script}
To compare the URL each request is made with the list of known tracker domains, we use the \cite{easylist}. In its original form, it contains a list of regular expression rules that match the different URL forms that a tracker domain might have. This means that to identify a tracker, we had to execute each rule and see if we get a match. This was extremely slow, and it caused the browser to completely freeze up on websites that had a large number of outgoing HTTP requests.

It was clear that we had to further refine the list to optimize the speed at which the HTTP requests were processed. To do this, we had to utilise the domains of the URLs since it is always the same regardless of the remaining URL. We therefore created a script that iterates through the EasyList and for each regular expression rule we extract the domain, and create a mapping between the domain and the corresponding regular expression rule. Then during the gameplay, for each URL we want to check for membership in the list, we can extract its domain in the same way that we have extracted it from the regular expression rules to ensure consistency, and check for membership in this mapping in constant time, which solves the problem of being too slow.

\subsection{Advert identification and categorisation}
To identify adverts on different websites inside the browser, we needed a different type of script that has access to each website's HTML content and can execute its logic separately in each website. Fortunately, chrome extensions allow us to inject scripts in pages programmatically, and execute their logic once. We created a script to handle advert categorisation and identification that we only inject into pages when the user is in an active game of the Category mode. 

Advert elements are typically served to the user through HTTP response objects and they are nested inside multiple iframe elements, making it hard to detect. In addition to the advert elements, scripts are embedded inside the iframe to detect interaction with the advert. The structure of the iframe makes it hard to identify adverts, since there are no clear indications in the form of tags that would allows us to identify which element is the advert consistently. However, the iframe element contains two children elements that we are interested in: A hyperlink element with the URL to the advert's landing page, and the advert's image element. Therefore, instead of looking through each element in the iframe, trying to detect adverts, we extract all the children hyperlink elements of the iframe and use a similar technique as that used by \cite{Liu2013} in their AdReveal tool to identify advert URLs. For each hyperlink, we extract the URL and check whether it contains the string 'adurl='. With this method, we can match adverts served by Google's DoubleClick, which is the most widely used ad exchange by publishers (\cite{dclick}). We were unable to find any other consistent method to identify adverts from other ad exchanges which means our gameplay is limited only to adverts served by Google. During test runs of the gameplay, it became apparent that this was not destructive to the gameplay, as we rarely came across adverts that were not served by Google.

%==================================================================================================================================
\chapter{Evaluation} 
In this chapter we evaluate user's knowledge of targeted advertising systems before and after playing the game, as well as the usability of the system by conducting an experiment. 
Before we discuss the results, it is important to note that we had trouble finding people to participate in this experiment. In total, 9 participants took part in the experiment, playing a total of 6 games: 5 games of the Race mode and 1 game of the Category mode. Seven participants took part in the experiment in groups; one was a group of 3 and the other was a group of 4 that played the game together. The remaining 2 participants played the game solo. Additionally, 6 of the participants were computer science students that were already exposed to these concepts through university courses. Due to the small number of participants and the fact that most of them were not the target audience, the conclusions reached from our analysis might not be generalisable. We discuss our methodology and our findings within these limitations.

\section{Experiment}
For the experiment, participants were asked to complete a survey. The survey included questions to evaluate the user's knowledge of targeted advertising systems, tracking and the privacy issues involved with these systems. It also included questions aimed at evaluating the system's usability in general. The survey first asked participants to rate their knowledge on a scale of 1 to 5 on various aspects of these systems. A rating of 1 means that the participant's knowledge is very poor and a rating of 5 means that the participant's knowledge is excellent. Participants were also asked to rate their technical proficiency, so that we can explore whether there is a relationship between the participant's technical knowledge and their knowledge in targeted advertising systems. The survey then included instructions on how to set up and play the game, and asked participants to play one game of the Race mode and read the information sections on the web app. After playing the game, participants were again asked to rate their knowledge on the same questions that they were asked before the gameplay. Finally, the survey included ten questions taken from the SUS questionnaire (\cite{sus}) aimed at evaluating the system's usability.

A better experiment would have been to ask people to play multiple games, as they would get more familiar with the gameplay and perhaps understand these concepts better. This would have also given us more data to analyse and better the player's behaviour and strategies. However, due to the difficulty in finding participants and the amount of time it took to complete the experiment (20-30 minutes), we did not want participants to feel like they were asked to do too much or waste too much of their time, because they might have chosen not to take part in the experiment at all.

\subsection{User Knowledge Of Targeted Advertising System}
Figure \ref{fig:know} shows a table of the responses for the knowledge questions from all the participants that took part in the experiment, along with the description of each question. As we can observe from the table, almost all participants rated at least one aspect of these systems higher after playing the game. The most significant result is the improvement in knowledge of targeted advertising systems, as 8 out of 9 participants reported an increase of 1 or more in their perceived knowledge rating. The other participant rated their knowledge as excellent, so there was no possibility for improvement there.
The increase in perceived knowledge could potentially mean that the participant's learned something they did not know before from playing the game, but there is not enough evidence to confirm that this is the case. It is worth noting that for the few participants that rated their technical proficiency low, the increase in perceived knowledge is more significant. This is because participants with higher technical proficiency are more likely to be exposed to these concepts. 

From the results it also seems that the participants did not feel like they learned something about the various privacy issues in targeted advertising systems. This might be because this concept was not directly related to the gameplay but instead information was given through the information sections and participants might have chosen not to read the information sections, even though they were asked to. An interesting result that we observed is that some participants rated their knowledge lower after playing the game. This is most prominent in the privacy issues question and it might mean two things: either the participants made a mistake or they realised that these systems are far more complex than they initially thought and they rated their knowledge lower to reflect this. However, as the survey responses were anonymous, we could not follow up to confirm this.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{images/know.pdf}    

    \caption{The responses to the survey's knowledge questions. Two columns for each question: one shows the responses before the participants played the game and the other shows the responses after. Bold numbers indicate an increase in knowledge and bold numbers with an asterisk indicate a decrease. The descriptions of each question can be seen below the table.}

    \label{fig:know} 
\end{figure}

Participants were also asked to vote on what types of websites they thought contain the most trackers. The different types of websites for the responses were as follows: `Social media websites such as Facebook`, `E-commerce websites such as Amazon`, `News or blog websites such as The Guardian` or `Streaming websites such as YouTube or Netflix`. There were initially 2 votes for all types of websites except news or blogs websites, which had 3 votes. 
After playing the game, participants were asked the same question again and all of the them chose `news or blog websites`, which as we found after experimenting with the game, is the right response. Typically these types of websites have a much larger number of trackers than other types of websites. This is because news or blog sites are plagued with advertising, since their profit comes from ad revenues. This results is important as it shows that participants were able to identify the type of websites that contain the most trackers after playing just one game.

\subsection{Gameplay Analysis}
To understand how the players interacted with the game, and how their strategy changed as they played the game, we analyse our gameplay logs as well as each player's game history. The logs contain information about different interactions that players performed during the game and the game history contains useful statistics about the game such as each player's page history. The page history is an ordered collection of the websites the player visited during the game, which means we can determine what types of websites they visited as the game progressed. 

When analysing the page history of the participants we noticed that most of them (6 out of 9) initially visited websites such as Amazon, Facebook, Netflix or YouTube. This is because it is fair to assume that these websites have a lot of tracking done as they use mass amounts of user data to build or enhance their systems. However, these websites usually do their own tracking by gathering data from interactions within the page, rather than by third-party tracking mechanisms. One participant initially visited a sports streaming website, which was a good strategy, as these types of websites usually have lots of trackers. The remaining two participants visited news websites, which we consider to be the optimal strategy and it shows that these participants already had some knowledge about trackers, and knew what to look for.
As the games progressed we observed some differences between the games with multiple players as opposed to the solo games. However, in both solo and multiplayer games, after visiting their initial set of websites, participants then went on trying other types of websites in an attempt to improve their strategy. 

For the multiplayer games we noticed that in the first game of both groups, one of the participants would quickly identify that news sites have the most trackers and they would keep visiting different news sites. 
In one of the multiplayer games, this particular participant won the game by a huge margin, since the other participants in that game were still trying out different strategies. This group was also the only group that played multiple games, and in their second game we observed that every single participant went straight for news websites, which means that they either discussed strategies inside the summary page or the other participants looked at the page history of the winner and understood what types of websites they should visit. Furthermore, the length of their first game was close to four minutes while the length of their second game was close to two minutes which shows that participants can improve their strategy drastically by playing just one game. The other multiplayer game was much closer in terms of score because the other participants managed to identify that news sites had the most trackers before the game ended. An interesting observation is that the other participants all started visiting news sites at the same time, shortly after the first participant. This could be by chance, if they were trying different types of websites or it could be that they were communicating while playing the game. This result is important, as it shows that participants can learn from other participants if they are collaborating. This introduces a new dimension of learning to the game through discussion with other more knowledgable participants.

The solo games were a bit different, as these participants took their time when visiting websites and visited more websites before getting tracked by the required amount of trackers. In both of the games, the participants started by visiting news sites and then went on to visit various types of websites and one of them even visited the University's homepage. This is most likely because they were interested in seeing the amount of tracking done in pages they usually visit. The two solo game were also the longest, with one game taking 8 minutes which was 2 minutes more than the longest multiplayer game.
The difference in player behaviour between solo games and multiplayer games is most likely due to the competitive factor of the game. A solo player has no competition and therefore they can take the time to explore the game, whereas multiple players may only be focused on optimizing the strategy in order to win first. 

For the one game of Category mode, the strategy of the players was almost exactly the same. The advert category given to them was 'Computer and Electronics' and the all visited retailers that sell electronic products and continued visiting different retailers until one of them won the game. This is interesting to see, as all of them went for the re-marketing targeting mechanism, which as we discussed in the \ref{related} section, targets the user with personalised adverts about products they either bought or interacted with.

\subsection{System Usability}
After playing the game, participants were asked to answer the 10 questions taken from the SUS questionnaire to evaluate the usability of the system. The responses to these questions can be transformed into a SUS score that indicates how good the usability of the system is. Table \ref{tab:sus} shows the responses to each question for all the users along with their SUS score. We calculate the average SUS score across all users and get a score of 80, which falls short of being excellent by 0.8, and it is classified as good according to the SUS score labels (\cite{susscore}). This means that users found our system quite enjoyable and easy to use and had not particular trouble using the different functionalities in the system. There is however a significant difference between the scores of some participants which indicates that some participants had more trouble interacting with the system than others.

\begin{table}
\centering
\resizebox{\linewidth}{!}{%
\setlength{\tabcolsep}{0.5em} % for the horizontal padding
\begin{tabular}{clllllllll}
\textbf{Question} & \textbf{P1} & \textbf{P2} & \textbf{P3} & \textbf{P4} & \textbf{P5} & \textbf{P6} & \textbf{P7} & \textbf{P8} & \textbf{P9} \\
I think that I would like to use this system frequently                                                                                            & 3 & 4 & 4 & 3 & 4 & 2 & 3 & 4 & 3  \\[5pt]
\rowcolor[rgb]{0.871,0.871,0.871} I found the system unnecessarily complex                                                                         & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 2  \\[5pt]
I thought the system was easy to use                                                                                                               & 4 & 5 & 4 & 5 & 5 & 4 & 5 & 4 & 5  \\[5pt]
\rowcolor[rgb]{0.871,0.871,0.871} I think I would need the support of a technical person to be able to use this system                             & 2 & 1 & 1 & 1 & 1 & 1 & 2 & 1 & 1  \\[5pt]
\textcolor[rgb]{0.125,0.129,0.141}{I found the various functions in this system were well integrated.}                                             & 4 & 5 & 4 & 4 & 5 & 4 & 4 & 5 & 3  \\[5pt]
\rowcolor[rgb]{0.871,0.871,0.871} \textcolor[rgb]{0.125,0.129,0.141}{I thought there was too much inconsistency in this system.}                   & 2 & 2 & 1 & 1 & 1 & 2 & 1 & 2 & 1  \\[5pt]
\textcolor[rgb]{0.125,0.129,0.141}{I would imagine that most people would learn to use this system very quickly.}                                  & 4 & 5 & 4 & 5 & 5 & 5 & 5 & 4 & 4  \\[5pt]
\rowcolor[rgb]{0.871,0.871,0.871} \textcolor[rgb]{0.125,0.129,0.141}{I found the system very cumbersome to use.}                                   & 2 & 2 & 2 & 1 & 1 & 2 & 2 & 1 & 2  \\[5pt]
\textcolor[rgb]{0.125,0.129,0.141}{I felt very confident using the system.}                                                                        & 3 & 5 & 3 & 5 & 4 & 4 & 3 & 4 & 3  \\[5pt]
\rowcolor[rgb]{0.871,0.871,0.871} \textcolor[rgb]{0.125,0.129,0.141}{I needed to learn a lot of things before I could get going with this system.} & 4 & 2 & 4 & 1 & 1 & 3 & 2 & 4 & 3 \\[5pt]
\textcolor[rgb]{0.125,0.129,0.141}{SUS Score}                                                                        & 65 & 87 & 72 & 92 & 95 & 75 & 80 & 80 & 72.5  \\[5pt]
\end{tabular}
}
\caption{A table showing the responses to the SUS questions from the survey. The SUS score for each user is also shown in the last row.}
\label{tab:sus}
\end{table}

\section{Unit Testing} 
The unit tests that we created were all to test the server's functionality. We created tests for each REST API route and for the utility functions of the server such as updating the achievements and player metrics. We used \cite{mocha}, which is a flexible JavaScript test framework that allowed us to define test suites separately to test each part of the system individually. We run these unit tests every time we pushed to our repository to ensure that the implementation of new features did not break the existing functionality. 
We used \cite{insta}, a JavaScript test coverage tool to automatically create a code coverage report for our unit test; a summary of the results is shown in Table \ref{tab:coverage}. As we can see from the table, the unit tests cover approximately 67\% of the lines and 55\% of the branches in all of the files. The reason for not having a better coverage is that we could not effectively create unit tests for the gameplay functionality or the different socket events, as it was really difficult to simulate the sequence of interactions that need to occur in order to find and play a game. The functionality of those parts of the system was tested manually, by playing the game and monitoring closely the state of our server to identify any potential errors. This means that there might be bugs in our gameplay logic and therefore, we gave players the option to report bugs from the web application through a form. However, there were no bug reports from any of the players and all the games in the experiments ran smoothly. 

\begin{table}
\centering
\resizebox{\linewidth}{!}{%
\setlength{\tabcolsep}{0.5em} % for the horizontal padding
\begin{tabular}{clll}
\textbf{Test Suite} & \textbf{Statement Coverage} & \textbf{Branch Coverage} & \textbf{Line Coverage} \\
All directories                                                                                            & 66.85 & 54.98 & 67.36  \\
\rowcolor[rgb]{0.871,0.871,0.871} REST API Routes                                                          & 51.12 & 45.56 & 52.14  \\
REST API Middleware                                                                                        & 84    & 60    & 84   \\
\rowcolor[rgb]{0.871,0.871,0.871} Sequelize Models                                                         & 100   & 100   & 100    \\
\textcolor[rgb]{0.125,0.129,0.141} Utilities	                                                   & 69.49   & 47.83   & 69.41    \\
\end{tabular}
}
\caption{A table showing the code coverage for the server's high level directories produced by Instanbul.}
\label{tab:coverage}
\end{table}

\section{Requirement Validation}
All of the functional requirements identified in the requirement elicitation phase, except one, were met. This is because almost all of the requirements were essential to the functionality of the system, as we avoided setting requirements for features that were not significant. The requirement that was not met is \textbf{\#14}, a voting functionality inside the lobby so that players could vote for the winning condition. This requirement was mostly set to give players the choice to vary the gameplay, depending on the winning condition voted. This feature was prioritised as a could-have, as we initially knew that we would only implement this feature after the game was working properly and if there was sufficient time. It became apparent that this type of feature was out of the scope of our project and therefore, we did not implement it. 

Functional requirement \textbf{\#7} stated that users could have the ability to change their profile picture. While this requirement was met, we did not implement a profile picture upload but rather gave players the option to select their profile picture from a set of robot icons with different colours. The reason for not allowing users to upload their own profile picture is to enforce anonymity but also because this was simpler to implement, as we felt that this feature was not important enough to spend the time building a profile picture upload system.

In terms of the non-functional requirements, the only requirement that was not fully met is \textbf{\#2}, the system should be easy to use for new users. One of the system usability questions asked participants to rate how much they agree with the statement 'I needed to learn a lot of things before I could get going with this system'. Most participants rated this question highly, as seen in Table \ref{tab:sus}, with an average across all participants of 2.67. This is because the instructions on setting up and configuring the extension to play the game were quite lengthy and the fact that the structure of the game was not something the participants were familiar with, and therefore, we had to provide some context to new players before they could play.  


%==================================================================================================================================
\chapter{Conclusion}    

\section{Summary}
For this project, we have created an online multiplayer game in order to investigate the knowledge users have about targeted advertising systems and tracking in web browsers and attempt to improve it. The game uses trackers and adverts as game resources in two different game modes and the premise is that by interacting with the game, users can observe directly and understand better what is happening behind the scenes in terms of tracking and advertising when they visit different websites. The game was implemented as a web application, which allows users to create accounts and search for games while at the same time earn achievements while playing. Additionally, a Chrome Extension was developed to enable the gameplay, as we need access to the user's DOM and network requests inside their browser to be able to identify trackers and adverts. 

In the background section we have discussed how targeted advertising systems work, what types of data trackers gather and how they do it, and the roles of the different entities involved in these systems. While the discussion was not all inclusive and we avoided delving into too much detail, it gives the reader the necessary context to understand the concepts in the game. 

Through the web app, users can search for a game, provided they have the extension enabled and configured correctly. They are then put in a lobby where they can chat with each other and see useful information about the winning condition and the status of the game. During the game, players visit websites in order to get tracked by a unique number of trackers in the case of the Race mode or get served an advert in a particular category in the case of the Category mode. When a winner is found, the players are redirected to a summary page where they can see useful statistics about the game as well as the scores and page history of other players. Finally, users can earn achievements while playing which they can view along with their gameplay metrics in their dashboard.

With the web application deployed, we ran an experiment in order to evaluate our system and determine if the player's knowledge about certain aspects of targeted advertising systems was improved after playing the game. While our evaluation was limited due to the small number of participants, we observed that almost all participants reported an increase in knowledge in at least one aspect after playing a single game of the Race mode. This is an important result, as these concepts are complex and difficult to comprehend without the appropriate background knowledge and an interactive game can be more appealing to users than a mountain of text. However, a more thorough evaluation is needed to reach this conclusion, as there is not enough evidence to say for certain that the participant's knowledge was improved. 

\section{Limitations}
\label{limitations}
There were three main limitation that were discussed in this paper which we summarise here in short. The first limitation is the tracker list that we use to identify trackers; this list contains domains of known trackers but it is not exhaustive, meaning that there are potential cases where we fail to identify a tracker because their domain is not in the list. We could have potentially combined multiple tracker lists but the limitation still remains, as it is safe to assume that there are tracker domains not found in any of these lists. The second limitation is the way we identify and categorise adverts, which limits the game only to Google's DoubleClick adverts. Additionally, we categorise adverts by their redirection URL, using a Web Categorisation API, which could either fail to categorise an advert or categorise it wrong. The third limitation was the small number of participants in the experiments and the fact that they did not represent the target audience. This made it difficult to reach conclusions that generalise with the limited data we had.

\section{Future Work}
When we were developing the game, we focused on important features that contribute to the functionality of the system. This means that there is a lot of room for additional features to be added that would enhance either the gameplay or the user experience. In this section, we will first discuss potential improvements for the limitations mentioned above and then propose general improvements to the project.

\subsection{Improvements to the limitations}
In the \ref{limitations} Section we have discussed how we are limited to identifying adverts only from Google's DoubleClick. While this did not seem to be a breaking issue during multiple test runs, it certainly could cause frustrations if a player sees an advert on the winning category but the extension fails to identify it and categorise it correctly because it was served by an ad exchange other than Google. Therefore, a good place to start if taking this project forward is trying to identify more patterns to match adverts from different ad exchanges. This could be done by manually examining advert elements that are not served by Google on different websites and trying to see if there is a common pattern between those elements that would enable the extension to consistently identify them. 

For the scope of this project, we have used a Web Categorisation API to categorise adverts. This is an easy and consistent way to categorise adverts by their redirection URLs but it is not perfect. We suggest to add a fallback mechanism that would give players the option to select a category for an advert they see during the game, if the extension failed to categorise it. This system should be very simple and intuitive to use, as to not be disruptive to the gameplay. However, while there is not a point in cheating, care must be taken to handle cases where players are being dishonest about an advert category. In the case where the game has multiple players, a solution could be to pair players together and have them confirm the other player's categorisation.

\subsection{User Experience Improvements}
The game is meant to be experimental and educational, but this does not mean that it can not be fun and engaging as well. While we have implemented common elements that online games usually have such as the leaderboard or the achievements, there are so many features that could be added to enhance the user experience. These features are not necessarily related to the gameplay but rather to the interactions that happen outside the game. One such feature is a friend system, that allows players to add other players to their friend list so they can invite them and play games together. When friends group up to play a game, there could be a system that rewards them or there could be a different set of achievements that are specific to the friend system. 

Furthermore, improvements can certainly be made to the overall look and design of the web application as well as the interface of the extension in order to look more modern and responsive.
More information sections could be added to provide information of more aspects of targeted advertising systems. In addition to the information sections, a learning hub could be added to the web app as well. This learning hub would have resources, such as videos or interactive quizzes that would help re-enforce the concepts seen when playing the game.

A voting system inside the lobby can be implemented, to allow users to personalize the gameplay. This was in the initial set of requirements but due to its priority, we did not manage to implement it in time. This voting system would present to the players multiple winning condition options. In the case of the Race mode, this could be a vote between different numbers of unique trackers that the users have to get tracked by to win the game. In the case of the Category mode, players would be presented with a subset of categories and the most voted category would then be the winning condition.

Finally, improvements can be made to the gameplay by either enhancing the existing game modes by adding more features, adding different types of feedback to the extension's interface, or by implementing more game modes that use different aspects of targeted advertising systems as game mechanics.

\subsection{Experiment and Evaluation Improvements}
The fact that we had a small number of participants made it difficult to interpret the gameplay and determine with certainty if playing the game improves the participant's knowledge of targeted advertising systems. Before moving forward with the development of new features, it would certainly be beneficial to run an evaluation experiment again with a wider and more diverse pool of participants. This is because a more thorough evaluation could indicate what area of the system needs the most improvements. For our experiment we asked users to play one single game of Race mode and optionally play more games of either game mode. Different experiments can also provide different data that could be used in conjunction with the data already gathered. For example, asking participants to play both game modes multiple times and observing how their strategy develops after playing multiple games.

The focus of our evaluation was mainly about user knowledge of targeted advertising systems but the game can be used to evaluate other concepts as well. For example, determining what role the player's location and demographics have on the category of adverts that they are being served. This could be done by having different groups of people with different demographics play the game from different locations and then analysing the results to see if there is a statistical difference between the distribution of advert categories seen by the different groups. 

As we have observed from trial runs of the game, the number of trackers on a page increases substantially as soon as you accept cookies. Therefore, another experiment could be determining how much does accepting or declining cookies in different websites them affect the personalisation of adverts. This could be done by having (or simulating) two groups of players with fresh browser accounts play the game and asking them to visit the same websites, in the same order, while collecting data about the categories of adverts seen by both groups. The first group would be accepting cookies and the second group would be declining them. This way, using the data gathered from the experiment, conclusions could be made about the effect that accepting cookies has on the category of adverts being served to the users. 

%==================================================================================================================================
%
% 
%==================================================================================================================================
%  APPENDICES  

\begin{appendices}

\chapter{Appendices}

\section{Ethics Checklist}

\includepdf[pages=-]{images/Ethics_Checklist.pdf}

\section{Design Evaluation Survey}

\includepdf[pages=-]{images/design_survey.pdf}

\section{Results For Design Evaluation}

\includepdf[pages=-]{images/design_responses.pdf}

\section{Gameplay Evaluation Survey}

\includepdf[pages=-]{images/gameplay_survey.pdf}

\section{Results For Gameplay Evaluation}

\includepdf[pages=-]{images/gameplay_responses.pdf}

\section{User Evaluation Survey}

\includepdf[pages=-]{images/user_evaluation_survey.pdf}

\section{Results For User Evaluation Survey}

\includepdf[pages=-]{images/user_responses.pdf}

\end{appendices}

%==================================================================================================================================
%   BIBLIOGRAPHY   

% The bibliography style is abbrvnat
% The bibliography always appears last, after the appendices.

\bibliographystyle{abbrvnat}

\bibliography{l4proj}

\end{document}
